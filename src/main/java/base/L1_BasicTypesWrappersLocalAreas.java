package base;

public class L1_BasicTypesWrappersLocalAreas {

    public static void localArea() {
        // ПРАВИЛО:
        // В коде можно создавать локальные области и в двух разных локальных областях хранить одноименные переменные.

        // Локальная область 1
        {
            int a = 1;
            System.out.println(a);
        }

        // System.out.println(a); - ОШИБКА: Переменная объявлена в локальной области и не существует за её пределами.

        // Локальная область 2
        {
            int a = 2;
            System.out.println(a);
        }

        int a = 3;
        System.out.println(a);

        /*
        ТАКЖЕ
        Локальными областями видимости являются области внутри циклов, методов, условий if else.
         */
    }

    public static void main(String[] args) {

        /*
         * В Java есть 8 примитивных типов, которые делят на 4 группы, вот они:
         * Целые числа - byte, short, int, long
         * Числа с плавающей точкой (иначе вещественные) - float, double
         * Логический - boolean
         * Символьный - char
         */

        // Примитивные типы копируются по значению. В примере для переменной b2 выделяется новая область в памяти
        // в которую записывается значение 10.

        int a2 = 10;
        int b2 = a2;

        // Ссылочные типы - это все остальные типы: строки, классы, перечисления и интерфейсы, а также массивы.
        // Ссылочные типы копируются по ссылке. В примере obj2 будет ввести на объект obj. Обе переменные будут менять один и тот же объект.

        Object obj = new Object();
        Object obj2 = obj;

        // ЦЕЛЫЕ ТИПЫ

        // 8-bits == 1 byte. ----------------------------------------------------------------------------

        // Целое со знаком. Диапазон - от -128 до +127.
        byte a = -128;
        byte b = +127;

        // 16-bits == 2 bytes. -------------------------------------------------------------------------

        // Целое со знаком. Диапазон - от -32768 до +32767.
        short c = -32768;
        short d = +32767;

        // 32-bits = 4 bytes. ---------------------------------------------------------------------------

        // Целое со знаком. Диапазон - от -2147483648 до +2147483647.
        int e = -2147483648;
        int f = +2147483647;

        /* Для задания шестнадцатеричного значения после символов 0x указывается число в шестнадцатеричном формате.
         * Таким же образом восьмеричное значение указывается после символа 0, а двоичное значение - после символов 0b.
         */

        int num111 = 0x6F; // 16-тиричная система, число 111
        int num8 = 010; // 8-ричная система, число 8
        int num13 = 0b1101; // 2-ичная система, число 13

        //  Также целые числа поддерживают разделение разрядов числа с помощью знака подчеркивания:
        int x = 123_456;

        // 64-bits = 8 bytes. ---------------------------------------------------------------------------

        // Целое со знаком. Диапазон - от -9223372036854775808 до +9223372036854775807.
        long g = -9223372036854775808L;
        long h = +9223372036854775807L;

        // ВЕЩЕСТВЕННЫЕ ТИПЫ

        /* Операции с числами с плавающей точкой
         * Следует отметить, что числа с плавающей точкой не подходят для финансовых и других вычислений, где ошибки при округлении могут быть критичными.
         * В данном случае переменная d будет равна не 0.9, как можно было бы изначально предположить, а 0.8999999999999999.
         * Подобные ошибки точности возникают из-за того, что на низком уровне для представления чисел с плавающей точкой применяется двоичная система,
         * однако для числа 0.1 не существует двоичного представления, также как и для других дробных значений.
         * Поэтому если в таких случаях обычно применяется класс BigDecimal, который позволяет обойти подобные сиуации.
         */

        double d1 = 2.0 - 1.1;
        System.out.println(d1);

        // Вещественные типы предназначены для представления дробных чисел.

        // 32-bits = 4 bytes. ---------------------------------------------------------------------------

        // Вещественное со знаком. Диапазон - от +/-1.5 x 10^-45 до +/-3.4 x 10^38.
        float i = -0.123456789f;  // Указание суффикса f, является обязательным,
        float j = +1.123456789F; // т.к., компилятор интерпретирует данное число как double.

        /* Числа с плавающей точкой
         * При присвоении переменной типа float дробного литерала с плавающей точкой, например, 3.1, 4.5 и т.д., Java автоматически рассматривает этот литерал как значение типа double.
         * И чтобы указать, что данное значение должно рассматриваться как float, нам надо использовать суффикс f / F:
         */

        float fl = 30.6f;
        double db = 30.6;

        // 64-bits = 8 bytes. ---------------------------------------------------------------------------

        // Вещественное со знаком. Диапазон - от +/-5.0 x 10^-324 до +/-1.7 x 10^308.
        double k = -0.123456789d;
        double l = +1.123456789;

        // ЛОГИЧЕСКИЙ ТИП

        // 8-bits == 1 byte. ----------------------------------------------------------------------------

        // Логическая величина Истина/Ложь.
        boolean m = true;
        boolean n = false;

        //СИМВОЛЬНЫЙ ТИП

        // 16-bits == 2 bytes. -------------------------------------------------------------------------
        // Символ в формате UNICODE.
        char o = 'A';       // Символ
        char p = 0x0041;    // Значение в 16-ричном формате
        char zzz = '\u0065';  // Значение в формате unicode
        char zzzz = 44545;  // числовой код символа из кодировки UTF-16

        // СТРОКОВОЙ ТИП

        // Строка в формате UNICODE.
        String firstString = "hello";
        String secondString = "HELLO";

        System.out.println(Integer.MAX_VALUE);
        System.out.println(Integer.MIN_VALUE);
    }

    public static void wrappers() {

        // Обертки
        // Если требуется создать ссылку на один из примитивных типов данных, необходимо использовать соответствующий класс-обертку.
        // Также в таких классах есть некоторые полезные методы и константы, например минимальное значение типа int можно узнать использовав константу Integer.MIN_VALUE.
        // Оборачивание примитива в объект называется упаковкой (boxing), а обратный процесс распаковкой (unboxing).

        //Тип	Класс-обертка
        //byte	Byte
        //short	Short
        //int	Integer
        //long	Long
        //char	Character
        //float	Float
        //double	Double
        //boolean	Boolean

        int i = 10;
        Integer boxed;
        // Обычное создание объекта
        boxed = new Integer(i);
        // Фабричный метод
        boxed = Integer.valueOf(i);
        // Автоматическая упаковка, компилятор просто вставит вызов Integer.valueOf
        boxed = i;

        // Рекомендуется использовать valueOf, он может быть быстрее и использовать меньше памяти потому что применяет кэширование, а конструктор всегда создает новый объект.
        // Получить примитив из объекта-обертки можно методом <имя примитивного типа>Value.

        Integer boxed2 = new Integer(10);
        int i2;
        // Явная распаковка
        i2 = boxed2.intValue();
        // Автоматическая распаковка
        i2 = boxed2;

        Integer myInt = 5;
        Double myDouble = 5.99;
        Character myChar = 'A';

        System.out.println(myInt.intValue());
        System.out.println(myDouble.doubleValue());
        System.out.println(myChar.charValue());
    }

}
